/*
题目描述
小明买了一些彩色的气球用绳子串在一条线上，想要装饰房间，每个气球都染上了一种颜色，每个气球的形状都是各不相同的。
我们用1到9一共9个数字表示不同的颜色，如12345则表示一串5个颜色各不相同的气球串。但小明希望得到不出现重复颜色的气球串，
那么现在小明需要将这个气球串剪成多个较短的气球串，小明一共有多少种剪法？
如原气球串12345的一种是剪法是剪成12和345两个气球串。

注意每种剪法需满足最后的子串中气球颜色各不相同（如果满足该条件，允许不剪，即保留原串）。
两种剪法不同当且仅当存在一个位置，在一种剪法里剪开了，而在另一种中没剪开。详见样例分析。

输入
第一行输入一个正整数n（1≤n≤100000），表示气球的数量。
第二行输入n个整数a1，a2，a3...an，ai表示该气球串上第i个气球的颜色。对于任意i，有1≤ai≤9。

样例输入
3
1 2 3

输出
输出一行，第一行输出一个整数，表示满足要求的剪法，输出最终结果除以1000000007后的余数。

样例输出
4

时间限制
C/C++语言：2000MS其它语言：4000MS
内存限制
C/C++语言：131072KB其它语言：655360KB
 */

/**
 * Approach: DP
 * 类似爬台阶的做法，属于 Climb Stairs 的升级版本。
 * dp[i]表示前i个气球组合的最大剪枝方法数，
 * 然后遍历当前位置的前 j 个位置作为断点，将所有可能的方案数（颜色不重复）加起来，
 * 就是当前方案的方案总数了。因为气球的颜色总共只有 10 中，
 * 所以向前遍历的步数不会超过 10.
 *
 * 时间复杂度：O(10 * N) => O(N)
 * 空间复杂度：O(N)
 */

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            int N = sc.nextInt();
            int[] balloons = new int[N];
            for (int i = 0; i < N; i++) {
                balloons[i] = sc.nextInt();
            }
            // dp[i]表示前i个气球组合的最大剪枝方法数
            int[] dp = new int[N + 1];

            dp[0] = 1;
            for (int i = 1; i <= N; i++) {
                int[] count = new int[10];
                // 把前面不相同的颜色的气球的剪枝数加起来即可
                // j向前遍历最多不会超过 10.（气球颜色只有 10 种）
                for (int j = i - 1; j >= 0; j--) {
                    // 如果出现重复颜色，直接break
                    if (++count[balloons[j]] > 1) {
                        break;
                    }
                    dp[i] = (dp[i] + dp[j]) % 1000000007;
                }
            }
            System.out.println(dp[N]);
        }
        sc.close();
    }
}