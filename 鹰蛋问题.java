鹰蛋问题之前，我们可以来分析一下更为简单的google面试题： 
200 层楼，扔两个鸡蛋求最坏情况下的最小代价。（详见下）

数学分析法：
碎子树：扔碎后需要扔第二枚的最坏情况
不碎子树：没扔碎，继续扔第一枚的最坏情况
目的是：找一个最矮的决策树。
使两子树中高度最大者尽量小, 我们的选择应当使两子树高度尽量接近.
最终希望的结果是, 整个二叉树尽量像一个满二叉树.

假设第一次在根节点上, 我们选择扔 k 层, 那么“碎子树”的高度显然是 k-1.
为了考虑不碎子树的高度, 设不碎后第二次扔 m 层(显然m>k), 
则这个新节点的碎子树高度为 m-k-1, 不碎子树高度仍然未知, 但按照满二叉树的目标,
我们认为它与碎子树相同或少1就好. 那么在根节点上的不碎子树的高度就是 m-k-1+1, 令它与碎子树高度相同, 于是:
m-k-1+1 = k-1 => m = k+k-1

也即, 如果第一次扔在 k 层, 第二次应该 高k-1 层, 这可以有直观一点的理解: 
每扔一次, 就要更保守一些, 所以让区间长度少1.   [1,k) => [k+1,2k-1). 
用类似刚才的分析, 可以继续得到, 下一次应该增高 k-2, 再下一次应该增高 k-3. 考虑:
k+(k-1)+...+1 = k(k+1)/2 = 200 => k≈20

知识补充：
https://www.zhihu.com/question/19690210

DP 解法：
m 表示层数：[1, n]
i 表示蛋的颗数
1. 若蛋碎了，则只能用 i-1 颗蛋在下面 m-1 层来确定高度，并且要求最坏情况下的次数最少。
即 f[i - 1, m - 1],总次数为 f[i - 1, m - 1] + 1
2. 若蛋没碎，这还能继续用这颗蛋在上面的 n-m 层来确定高度。而这其实可以看作是 1~n-m 层
求最坏情况下的最小代价。总次数为 f[i, n-m] + 1
题目要求在最坏情况下取最小代价，故应该在这两种情况中取最大者，并且要求在所有决策中取最小值。
    ans = min([max([f(i - 1, m - 1), f(i, n-m)]) + 1   

/*
一幢 200 层的大楼,给你两个鸡蛋. 如果在第 n 层扔下鸡蛋,鸡蛋不碎,那么从前 n-1 层扔鸡蛋都不碎. 
这两只鸡蛋一模一样,不碎的话可以扔无数次. 已知鸡蛋在0层扔不会碎.
提出一个策略, 要保证能测出鸡蛋恰好会碎的楼层, 并使此策略在最坏情况下所扔次数最少.
*/  

// Solution 1: Mathematical Method
public class Solution {
    public int dropEggs(int n) {
        long ans = 0;
        for (int i = 1; ; ++i) {
            ans += (long)i;
            if (ans >= (long)n)
                return i;
        }
    }
}

// Solution 2: DP

接下来我们再来看看鹰蛋问题，其实质与扔鸡蛋问题是一样的，
只是蛋的个数由原来的 2 变成了 k.
状态转移方程分析见上面的 DP 解法分析部分。

鹰蛋问题 5 重优化：
http://www.doc88.com/p-4744136032917.html

/*
有一堆共 M 个鹰蛋，一位教授想研究这些鹰蛋的坚硬度 E。
他是通过不断从一幢 N 层的楼上向下扔鹰蛋来确定 E 的。
当鹰蛋从第 E 层楼及以下楼层落下时是不会碎的，但从第（E+1）层楼及以上楼层向下落时会摔碎。
如果鹰蛋未摔碎，还可以继续使用；但如果鹰蛋全碎了却仍未确定 E，这显然是一个失败的实验。教授希望实验是成功的。

例如：若鹰蛋从第 1 层楼落下即摔碎，E=0；若鹰蛋从第 N 层楼落下仍未碎，E=N。
这里假设所有的鹰蛋都具有相同的坚硬度。给定鹰蛋个数 M 与楼层数 N。
要求最坏情况下确定 E 所需要的最少次数。

样例：
M = 1, N = 10
M = 2, N = 100

输出：
ANS = 10
ANS = 14

*/

class Solution {
    /**
     * @param m 蛋的数目
     * @param n 楼层的高度
     * @return 最坏情况下的最小代价(扔多少次)
     */
    public int dropEggs(int m, int n) {
        if (n == 0) {
            return 0;
        }
        
        int ans = 0;
        int[][] dp = new int[m+1][n+1];
        for (int i = 1; i <= n; ++i) {
            dp[1][i] = i;
        }

        for(int i = 2; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i][j-1] + 1;
                for(int k = 1; k < j; ++k) {
                    dp[i][j] = Math.min(dp[i][j], 
                                        Math.max(dp[i-1][k-1], dp[i][j-k]) + 1);
                }
            }
        }
        
        return dp[m][n];
    }
}
