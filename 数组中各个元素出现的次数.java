该题的解法第一反应便是开辟额外 O(N) 空间的数组。
数组的 index 代表出现的元素，数组中储存的 value 代表该元素出现的次数。
这样遍历一遍数组便能够得到答案。 时间复杂度为: O(n)

但是该题要求不能开辟额外的空间，故我们只能考虑将该信息储存到原来的数组中。
但是将该信息放进原数组之后，原本的信息将被覆盖。因此我们必须先将原本的信息拿出来，
然后再放进与次数相关的信息。并且拿出来的信息（即数组中的元素）必须被马上使用。
不然堆积起来，我们又要开辟空间去储存它。因此我们可以将其当作数组的 index 去访问下一个元素。
（因为index范围为：0~n-1,所以取出该元素后记得 -1）
但是我们如何区别我们访问到的数是代表着 出现的次数 还是 数组中原本的元素呢？（即是否被访问过）
如何让一个值体现这两种属性呢？我们知道一个数除了大小外还有正负这个属性，
因此这里便将被访问过的元素设为负值（因为原数组中元素均为正值且没被碰过），
于是第一次遇到某个元素时现将它清零后-1，以后每遇到一次就-1。最后将值取反便得到各元素对应的出现次数。
到这里我们已经想出来如何解决该题了。接下来只需要遍历一遍原数组即可。
时间复杂度为：O(n)

/*
问题描述：
给定一个整数数组a，长度为N，元素取值范围为[1,N]。
统计各个元素出现的次数，要求时间复杂度为O(N)，空间复杂度为O(1)。

示例：
输入：
7 
1 4 1 4 2 1 0
输出：
1,3 2,1 3,0 4,2 5,0 6,0 7,0
*/

class Solution {
    public static void elementCounter(int[] nums, int n) {
        int index = 0;
        while (index < n) {
            int temp = nums[index] - 1;
            // 该元素已经访问过，代表的是出现次数，跳过
            if (temp < 0) {
                index++;
                continue;
            // 第一次遇到该值
            } else if (nums[temp] > 0) {
                // 将该元素暂存起来，并将次数置为 -1
                nums[index] = nums[temp];
                nums[temp] = -1;
            // 不是第一次处理该值了
            } else {
                // 没有新元素需要处理，置0，并将次数 -1
                nums[index] = 0;
                nums[temp]--;
            }
        }
        
        for (int i = 0; i < n; i++) {
            System.out.print(i+1 + "," + -nums[i] + "\t");
        }
    }
}
