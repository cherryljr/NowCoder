数学分析法：
碎子树：扔碎后需要扔第二枚的最坏情况
不碎子树：没扔碎，继续扔第一枚的最坏情况
目的是：找一个最矮的决策树。
使两子树中高度最大者尽量小, 我们的选择应当使两子树高度尽量接近.
最终希望的结果是, 整个二叉树尽量像一个满二叉树.

假设第一次在根节点上, 我们选择扔 k 层, 那么“碎子树”的高度显然是 k-1.
为了考虑不碎子树的高度, 设不碎后第二次扔 m 层(显然m>k), 
则这个新节点的碎子树高度为 m-k-1, 不碎子树高度仍然未知, 但按照满二叉树的目标,
我们认为它与碎子树相同或少1就好. 那么在根节点上的不碎子树的高度就是 m-k-1+1, 令它与碎子树高度相同, 于是:
m-k-1+1 = k-1 => m = k+k-1

也即, 如果第一次扔在 k 层, 第二次应该 高k-1 层, 这可以有直观一点的理解: 
每扔一次, 就要更保守一些, 所以让区间长度少1.   [1,k) => [k+1,2k-1). 
用类似刚才的分析, 可以继续得到, 下一次应该增高 k?2, 再下一次应该增高 k?3. 考虑:
k+(k-1)+...+1 = k(k+1)/2 = 200 => k≈20

知识补充：
https://www.zhihu.com/question/19690210

DP 解法：
ans = min([max([f(i - 1, m - 1), f(n - i, m)]) + 1   i的范围为 [1, n]

/*
一幢 200 层的大楼,给你两个鸡蛋. 如果在第 n 层扔下鸡蛋,鸡蛋不碎,那么从前 n-1 层扔鸡蛋都不碎. 
这两只鸡蛋一模一样,不碎的话可以扔无数次. 已知鸡蛋在0层扔不会碎.
提出一个策略, 要保证能测出鸡蛋恰好会碎的楼层, 并使此策略在最坏情况下所扔次数最少.
*/  

// Solution 1: Mathematical Method
public class Solution {
    public int dropEggs(int n) {
        long ans = 0;
        for (int i = 1; ; ++i) {
            ans += (long)i;
            if (ans >= (long)n)
                return i;
        }
    }
}

// Solution 2: DP

